package main

import (
	"log"
	"math/rand/v2"
	"time"

	jen "github.com/dave/jennifer/jen"
)

func generateCodeWithJennifer(outputFile string, mapFuncs map[string]MapFunc) {
	f := jen.NewFile("mapper")
	f.Comment("Code generated by go-mapping-jam. DO NOT EDIT.")

	for _, mapFunc := range mapFuncs {
		genMap(f, mapFunc.Name, mapFunc.Source, mapFunc.Target, mapFunc)
	}

	err := f.Save(outputFile)
	if err != nil {
		log.Fatalf("failed to save file: %v", err)
	}
}

var mappers = make(map[string]string)

func genMap(f *jen.File, methodName string, sourceStruct *Struct, targetStruct *Struct, mapFunc MapFunc) {
	mapF := f.Func().Id(methodName)
	if sourceStruct.Path == currentPath {
		mapF.Params(jen.Id("src").Id(sourceStruct.Name))
	} else {
		mapF.Params(jen.Id("src").Qual(sourceStruct.Path, sourceStruct.Name))
	}

	if targetStruct.Path == currentPath {
		mapF.Id(targetStruct.Name)
	} else {
		mapF.Qual(targetStruct.Path, targetStruct.Name)
	}

	mapF.BlockFunc(func(g *jen.Group) {
		if targetStruct.Path == currentPath {
			g.Id("target").Op(":=").Id(targetStruct.Name + "{}")
		} else {
			g.Id("target").Op(":=").Qual(targetStruct.Path, targetStruct.Name+"{}")
		}

		for targetFieldName, targetField := range targetStruct.Fields {
			quals := mapFunc.Rules[Qual]
			sourceFieldName := targetFieldName
			var mname string
			var mpath string
			for _, q := range quals {
				if q, ok := q.(QualRule); ok && q.TargetName == targetField.FullName() {
					if q.SourceName != "" {
						sourceFieldName = q.SourceName
					}

					if q.MName != "" {
						mname = q.MName
						mpath = q.MPath
					}
				}
			}

			if sourceField, ok := sourceStruct.Fields[sourceFieldName]; ok {
				if mname != "" {
					if mpath != "" {
						g.Id("target").Dot(targetFieldName).Op("=").Qual(mpath, mname).Call(jen.Id("src").Dot(sourceFieldName))
					} else {
						g.Id("target").Dot(targetFieldName).Op("=").Id(mname).Call(jen.Id("src").Dot(sourceFieldName))
					}
				} else if _, ok := sourceField.Desc.(*Primetive); ok {
					g.Id("target").Dot(targetFieldName).Op("=").Id("src").Dot(sourceFieldName)
				} else if nestedSourceStruct, ok := sourceField.Desc.(*Struct); ok {
					hash := nestedSourceStruct.Hash() + targetField.Desc.(*Struct).Hash()
					methodName, ok := mappers[hash]
					if !ok {
						methodName = genRandomName(15)
						mappers[hash] = methodName
					}
					g.Id("target").Dot(targetFieldName).Op("=").Id(methodName).Call(jen.Id("src").Dot(sourceFieldName))

					if !ok {
						genMap(f, methodName, nestedSourceStruct, targetField.Desc.(*Struct), mapFunc)
					}
				} else if _, ok := sourceField.Desc.(*PrimetiveSlice); ok {
					g.Id("target").Dot(targetFieldName).Op("=").Id("src").Dot(sourceFieldName)
				}
			}
		}

		g.Return(jen.Id("target"))
	})
}

const charset = "abcdefghijklmnopqrstuvwxyz"

func genRandomName(length int) string {
	seed := time.Now().UnixNano()

	src := rand.NewPCG(uint64(seed), uint64(seed>>32))
	r := rand.New(src)

	result := make([]byte, length)
	for i := range result {
		result[i] = charset[r.IntN(len(charset))]
	}
	return string(result)
}
