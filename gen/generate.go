package gen

import (
	"fmt"
	"log"

	"github.com/dave/jennifer/jen"
	"github.com/udisondev/go-mapping-jam/mapp"
)

const charset = "abcdefghijklmnopqrstuvwxyz"

type mapperFunc struct {
	isRoot             bool
	file               *jen.File
	generatedFn        *jen.Statement
	mapper             mapp.Mapper
	source             mapp.Field
	target             mapp.Field
	submappers         map[string]string
	fieldMapGenerators map[mapp.TypeFamily]map[mapp.TypeFamily]func(bl mapperBlock, s, t mapp.Field)
}

type mapperBlock struct {
	*jen.Group
	mapperFunc
}

func Generate(mf mapp.MapperFile) {
	f := jen.NewFile("mapper")

	f.Comment("Code generated by go-mapping-jam. DO NOT EDIT.")

	submappers := make(map[string]string)
	fieldMapGenerators := map[mapp.TypeFamily]map[mapp.TypeFamily]func(bl mapperBlock, s, t mapp.Field){
		mapp.FieldTypeBasic: {
			mapp.FieldTypeBasic:   basicToBasic,
			mapp.FieldTypePointer: basicToPointer},
		mapp.FieldTypePointer: {
			mapp.FieldTypeBasic:   pointerToBasic,
			mapp.FieldTypeStruct:  pointerToStruct,
			mapp.FieldTypePointer: pointerToPointer,
		},
		mapp.FieldTypeStruct: {
			mapp.FieldTypeStruct:  structToStruct,
			mapp.FieldTypePointer: structToPointer,
		},
		mapp.FieldTypeSlice: {mapp.FieldTypeSlice: sliceToSlice},
		mapp.FieldTypeNamed: {mapp.FieldTypeNamed: namedToNamed},
	}
	for _, m := range mf.Mappers() {
		mfn := mapperFunc{
			isRoot:             true,
			file:               f,
			generatedFn:        f.Func().Id(m.Name()),
			mapper:             m,
			submappers:         submappers,
			fieldMapGenerators: fieldMapGenerators,
		}
		f.Line()
		mfn.generateSignature()
		mfn.generateBlock()
	}

	err := f.Save("./mapper/mapper_impl.go")
	if err != nil {
		log.Fatalf("failed to save file: %v", err)
	}
}

func (m mapperFunc) generateSignature() {
	if !m.isRoot {
		m.generatedFn.Params(jen.Id("src").Qual(m.source.Type().Path(), m.source.Type().TypeName()))
		m.generatedFn.Qual(m.target.Type().Path(), m.target.Type().TypeName())
		return
	}

	for i, p := range m.mapper.Params() {
		_, typeName := p.Type()
		pname := p.Name()
		if i == 0 {
			pname = "src"
		}
		m.generatedFn.Params(jen.Id(pname).Qual(p.Path(), typeName))
	}

	for _, r := range m.mapper.Results() {
		_, typeName := r.Type()
		m.generatedFn.Qual(r.Path(), typeName)
	}
}

func (m mapperFunc) generateBlock() {
	m.generatedFn.BlockFunc(func(g *jen.Group) {
		bl := mapperBlock{
			Group:      g,
			mapperFunc: m,
		}
		var targetPath string
		var targetTypeName string
		var targetFields []mapp.Field

		if m.isRoot {
			target := m.mapper.Target()
			targetPath = target.Path()
			_, t := target.Type()
			targetTypeName = t
			targetFields = target.Fields()
		} else {
			target := m.target
			targetPath = target.Type().Path()
			targetTypeName = target.Type().TypeName()
			targetFields = target.Fields()
		}

		bl.Id("target").Op(":=").Qual(targetPath, targetTypeName+"{}")
		bl.Line()
		for _, tf := range targetFields {
			bl.generateTargetMapping(tf)
		}
		bl.Line()
		bl.Return(jen.Id("target"))
	})

}

func (bl mapperBlock) generateTargetMapping(target mapp.Field) {
	_, ok := bl.mapper.RulesByFieldFullNameAndType(target.FullName(), mapp.RuleTypeIgnore)
	if ok {
		return
	}

	source, ok := bl.mapper.SourceFieldByTarget(target.FullName())
	if !ok {
		panic(fmt.Sprintf("not found source field for target: %s", target.FullName()))
	}

	genFn, ok := bl.fieldMapGenerators[source.Type().TypeFamily()][target.Type().TypeFamily()]
	if !ok {
		panic(fmt.Sprintf("unsupported mapping from: %s to %s", source.Type().TypeFamily(), target.Type().TypeFamily()))
	}

	genFn(bl, source, target)
}
