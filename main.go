package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"strings"

	"golang.org/x/tools/go/packages"
)

type Import struct {
	Name string
	Path string
}

type StructHash string
type FieldHash string

type Struct struct {
	Name   string
	Pack   string
	Path   string
	Fields []Field
}

type Field struct {
	Name   string
	Type string
	Struct *FielsStruct
}

type FielsStruct struct {
	Parent Field
	Name string
	Type string
	Fields []Field
}

type Rule struct {
	Value string
}

type MapFunc struct {
	Name   string
	Source *Type
	Target *Type
	Rules  []Rule
}

type Type struct {
	Pack   string
	Name   string
	Import Import
	Struct *Struct
}

const projectName = "github.com/udisondev/go-mapping-jam/"

func main() {
	// Путь к файлу с интерфейсом
	interfaceFile := "./mapper/mapper.go"

	// Читаем исходный код
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, interfaceFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("failed to parse file: %v", err)
	}

	imports := make(map[ImportAlias]Import)
	mapFuncs := make(map[string]MapFunc)
	structs := make(map[StructHash]*Struct)
	structField := make(map[])
	imports[ImportAlias(".")] = Import{Path: projectName + "/mapper"}

	for _, v := range node.Imports {
		imp := extractMapImport(v)
		imports[ImportAlias(imp.Name)] = imp
	}

	astMethods := extractMethods(node)

	for _, v := range astMethods {
		mappingRules := make([]Rule, 0, len(v.Doc.List))
		for _, mpr := range v.Doc.List {
			mappingRules = append(mappingRules, Rule{
				Value: mpr.Text,
			})
		}

		if fType, ok := v.Type.(*ast.FuncType); ok {
			source := extractType(fType.Params, imports)
			target := extractType(fType.Results, imports)
			structs[source.Hash()] = source.Struct
			structs[target.Hash()] = target.Struct
			m := MapFunc{
				Name:   v.Names[0].Name,
				Source: &source,
				Target: &target,
				Rules:  mappingRules,
			}

			mapFuncs[m.Name] = m
		}
	}

	// mapFuncs := make([]mapper, 0, len(node.Scope.Objects))

	// Ищем интерфейс Mapper и метод

	// Загружаем пакеты проекта
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedImports | packages.NeedSyntax,
		Fset: fset,
	}

	structPathMap := make(map[StructHash]string)

	for _, v := range structs {
		structPathMap[v.Hash()] = DirFromPack(v.Pack)
	}

	structPackMap := make(map[StructHash]*packages.Package)
	uploadPacks := func(hash StructHash, dir string) {
		pks, err := packages.Load(cfg, dir)
		if err != nil {
			panic(err)
		}
		structPackMap[hash] = pks[0]
	}

	for k, v := range structPathMap {
		uploadPacks(k, v)
	}

	for s, p := range structPackMap {
		path := p.ID
		fmt.Println(path)
		fillObjs(structs[s], p)
	}

	// pkgs, err := packages.Load(cfg, ".")
	// if err != nil {
	// 	log.Fatalf("failed to load packages: %v", err)
	// }

	// // Извлекаем типы структур
	// var sourceType, targetType *ast.StructType
	// for _, pkg := range pkgs {
	// 	for _, syntax := range pkg.Syntax {
	// 		ast.Inspect(syntax, func(n ast.Node) bool {
	// 			if ts, ok := n.(*ast.TypeSpec); ok {
	// 				if ts.Name.Name == sourceStruct {
	// 					sourceType, _ = ts.Type.(*ast.StructType)
	// 				}
	// 				if ts.Name.Name == targetStruct {
	// 					targetType, _ = ts.Type.(*ast.StructType)
	// 				}
	// 			}
	// 			return true
	// 		})
	// 	}
	// }

	// if sourceType == nil || targetType == nil {
	// 	log.Fatalf("failed to find source or target structures")
	// }

	// // Создаем файл для генерации
	// f := jen.NewFile("mapper")
	// f.Comment("Code generated by generate.go. DO NOT EDIT.")

	// // Генерируем функцию реализации
	// f.Func().Id(fmt.Sprintf("%sImpl", methodName)).Params(jen.Id("src").Id(sourceStruct)).Qual(targetPackage, targetStruct).BlockFunc(func(g *jen.Group) {
	// 	g.Return(jen.Qual(targetPackage, targetStruct).ValuesFunc(func(values *jen.Group) {
	// 		// Динамически добавляем поля
	// 		for _, sourceField := range sourceType.Fields.List {
	// 			for _, targetField := range targetType.Fields.List {
	// 				// Проверяем совпадение имен
	// 				if len(sourceField.Names) > 0 && len(targetField.Names) > 0 &&
	// 					sourceField.Names[0].Name == targetField.Names[0].Name {
	// 					values.Id(targetField.Names[0].Name).Op(":").Id("src").Dot(sourceField.Names[0].Name)
	// 				}
	// 			}
	// 		}
	// 	}))
	// })

	// // Сохраняем сгенерированный файл
	// outputFile := filepath.Join(".", "mapper_generated.go")
	// err = f.Save(outputFile)
	// if err != nil {
	// 	log.Fatalf("failed to save generated file: %v", err)
	// }

	// log.Printf("Generated file: %s", outputFile)

}

func extractMapImport(i *ast.ImportSpec) Import {
	out := Import{}
	path := strings.ReplaceAll(i.Path.Value, "\"", "")
	out.Path = path

	if i.Name != nil {
		out.Name = i.Name.Name
		return out
	}

	pathElements := strings.Split(path, "/")
	lastPathElement := pathElements[len(pathElements)-1]
	out.Name = lastPathElement

	return out
}

func extractMethods(n ast.Node) []*ast.Field {
	out := []*ast.Field{}
	ast.Inspect(n, func(n ast.Node) bool {
		if iface, ok := n.(*ast.TypeSpec); ok && iface.Name.Name == "Mapper" {
			if ifaceType, ok := iface.Type.(*ast.InterfaceType); ok {
				out = append(out, ifaceType.Methods.List...)
			}
		}
		return true
	})

	return out
}

func extractType(v *ast.FieldList, impMap map[ImportAlias]Import) Type {
	out := Type{}
	switch expr := v.List[0].Type.(type) {
	case *ast.Ident:
		imp := impMap[ImportAlias(".")]
		out.Import = imp
		out.Name = expr.Name
		out.Struct = &Struct{
			Name: expr.Name,
			Pack: imp.Path,
		}
	case *ast.SelectorExpr:
		out.Pack = expr.X.(*ast.Ident).Name
		imp := impMap[ImportAlias(out.Pack)]
		out.Import = imp
		out.Name = expr.Sel.Name
		out.Struct = &Struct{
			Name: expr.Sel.Name,
			Pack: imp.Path,
		}
	}

	return out
}

func (s Struct) Hash() StructHash {
	if s.Path == "" {
		fmt.Sprintf("%s.%s", s.Pack, s.)
	}
	return StructHash(s.Pack + "." + s.Name)
}

func (i Import) Dir() string {
	return fmt.Sprintf("./%s", strings.ReplaceAll(i.Path, projectName, ""))
}

func DirFromPack(pack string) string {
	return fmt.Sprintf("./%s", strings.ReplaceAll(pack, projectName, ""))
}

func fillObjs(fieldSet func(f Field), p *ast.TypeSpec, stMap map[StructHash]*Struct, path string) *Struct {
	if ts, ok := p.Type.(*ast.StructType); ok {
		panic("is not a struct")
	} else {
		if isDepth(ts) {
			str := &Struct{
				Name: p.Name.Name,
				Pack: path,
			}

		}
	}

}

func buildField(f *ast.Field, pack string) Field {
	t, ok := f.Type.(*ast.Ident)
	if !ok {
		panic("field type is not ast.Ident")
	}
	if t.Obj == nil {
		return Field{
			Name: f.Names[0].Name,
			Type: Type{
				Pack:   pack,
				Name:   t.Name,
				Struct: nil,
			},
		}
	}

	Struct{
		Name: t.Obj.Name,
		Pack: pack,
	}
}

func isDepth(s *ast.StructType) bool {
	for _, v := range s.Fields.List {
		if t, ok := v.Type.(*ast.Ident); ok {
			if t.Obj != nil {
				return false
			}
		}
	}
	return true
}
