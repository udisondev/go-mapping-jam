package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"strings"

	"golang.org/x/tools/go/packages"
)

type mapImport struct {
	name string
	path string
}

func (m mapImport) isNil() bool {
	return m.path == ""
}

func (m mapImport) dir() string {
	return fmt.Sprintf("./%s", strings.ReplaceAll(m.path, projectName, ""))
}

type mapTypeGoal uint8

const (
	target mapTypeGoal = iota
	source
)

type mapType struct {
	pack  string
	imp mapImport
	value string
	goal  mapTypeGoal
}

type mapping struct {
	value string
}

type mapper struct {
	methodName string
	source     mapType
	target     mapType
	mappings   []mapping
}

const projectName = "github.com/udisondev/go-mapping-jam/"

func main() {
	// Путь к файлу с интерфейсом
	interfaceFile := "./mapper/mapper.go"

	// Читаем исходный код
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, interfaceFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("failed to parse file: %v", err)
	}

	mapImports := make([]mapImport, 0, len(node.Imports))

	for _, v := range node.Imports {
		mapImports = append(mapImports, extractMapImport(v))
	}

	astMethods := extractMethods(node)

	mappers := make([]mapper, 0, len(astMethods))

	for _, v := range astMethods {
		mappingRules := make([]mapping, 0, len(v.Doc.List))
		for _, mpr := range v.Doc.List {
			mappingRules = append(mappingRules, mapping{
				value: mpr.Text,
			})
		}

		if fType, ok := v.Type.(*ast.FuncType); ok {
			mappers = append(mappers, mapper{
				methodName: v.Names[0].Name,
				source:     extractMapType(fType.Params, source),
				target:     extractMapType(fType.Results, target),
				mappings:   mappingRules,
			})
		}
	}

	for idx, v := range mappers {
		if v.source.pack != "" {
			for _, i := range mapImports {
				if v.source.pack == i.name {
					mappers[idx].source.imp = i
				}
			}
		}
		if v.target.pack != "" {
			for _, i := range mapImports {
				if v.target.pack == i.name {
					mappers[idx].target.imp = i
				}
			}
		}
	}

	// mapFuncs := make([]mapper, 0, len(node.Scope.Objects))

	// Ищем интерфейс Mapper и метод

	// Загружаем пакеты проекта
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedImports | packages.NeedSyntax,
		Fset: fset,
	}

	pksDirs = map[string]struct{}

	pkgs := make(map[string]*packages.Package)

	for _, v := range mappers {
		getDir()
		uploadPacks := func(dir, strName string) {
			pks, err := packages.Load(cfg, dir)
			if err != nil {
				panic(err)
			}
			pkgs[strName] = pks[0]
		}

		if !v.source.imp.isNil() {
			uploadPacks(v.source.imp.dir(), v.source.value)	
		}

		if !v.target.imp.isNil() {
			uploadPacks(v.target.imp.dir(), v.target.value)	
		}

	}

	fmt.Println(pkgs)	

	// pkgs, err := packages.Load(cfg, ".")
	// if err != nil {
	// 	log.Fatalf("failed to load packages: %v", err)
	// }

	// // Извлекаем типы структур
	// var sourceType, targetType *ast.StructType
	// for _, pkg := range pkgs {
	// 	for _, syntax := range pkg.Syntax {
	// 		ast.Inspect(syntax, func(n ast.Node) bool {
	// 			if ts, ok := n.(*ast.TypeSpec); ok {
	// 				if ts.Name.Name == sourceStruct {
	// 					sourceType, _ = ts.Type.(*ast.StructType)
	// 				}
	// 				if ts.Name.Name == targetStruct {
	// 					targetType, _ = ts.Type.(*ast.StructType)
	// 				}
	// 			}
	// 			return true
	// 		})
	// 	}
	// }

	// if sourceType == nil || targetType == nil {
	// 	log.Fatalf("failed to find source or target structures")
	// }

	// // Создаем файл для генерации
	// f := jen.NewFile("mapper")
	// f.Comment("Code generated by generate.go. DO NOT EDIT.")

	// // Генерируем функцию реализации
	// f.Func().Id(fmt.Sprintf("%sImpl", methodName)).Params(jen.Id("src").Id(sourceStruct)).Qual(targetPackage, targetStruct).BlockFunc(func(g *jen.Group) {
	// 	g.Return(jen.Qual(targetPackage, targetStruct).ValuesFunc(func(values *jen.Group) {
	// 		// Динамически добавляем поля
	// 		for _, sourceField := range sourceType.Fields.List {
	// 			for _, targetField := range targetType.Fields.List {
	// 				// Проверяем совпадение имен
	// 				if len(sourceField.Names) > 0 && len(targetField.Names) > 0 &&
	// 					sourceField.Names[0].Name == targetField.Names[0].Name {
	// 					values.Id(targetField.Names[0].Name).Op(":").Id("src").Dot(sourceField.Names[0].Name)
	// 				}
	// 			}
	// 		}
	// 	}))
	// })

	// // Сохраняем сгенерированный файл
	// outputFile := filepath.Join(".", "mapper_generated.go")
	// err = f.Save(outputFile)
	// if err != nil {
	// 	log.Fatalf("failed to save generated file: %v", err)
	// }

	// log.Printf("Generated file: %s", outputFile)
}

func extractMapImport(i *ast.ImportSpec) mapImport {
	out := mapImport{}
	path := strings.ReplaceAll(i.Path.Value, "\"", "")
	out.path = path

	if i.Name != nil {
		out.name = i.Name.Name
		return out
	}

	pathElements := strings.Split(path, "/")
	lastPathElement := pathElements[len(pathElements)-1]
	out.name = lastPathElement

	return out
}

func extractMethods(n ast.Node) []*ast.Field {
	out := []*ast.Field{}
	ast.Inspect(n, func(n ast.Node) bool {
		if iface, ok := n.(*ast.TypeSpec); ok && iface.Name.Name == "Mapper" {
			if ifaceType, ok := iface.Type.(*ast.InterfaceType); ok {
				out = append(out, ifaceType.Methods.List...)
			}
		}
		return true
	})

	return out
}

func extractMapType(v *ast.FieldList, goal mapTypeGoal) mapType {
	out := mapType{goal: goal}
	switch expr := v.List[0].Type.(type) {
	case *ast.Ident:
		out.value = expr.Name
	case *ast.SelectorExpr:
		out.pack = expr.X.(*ast.Ident).Name
		out.value = expr.Sel.Name
	}

	return out
}
