package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"log"
	"strings"

	"golang.org/x/tools/go/packages"
)

type StructHash string
type FieldHash string
type ImportAlias string
type FieldName string
type Pack string
type Direction uint8

type FullType struct {
	ShortPackName string
	StructName    string
}

const (
	Source Direction = iota + 1
	Target
)

type Import struct {
	Alias ImportAlias
	Pack  Pack
}

type StructField interface {
	isField()
}

func (s *Struct) isField()    {}
func (p *Primetive) isField() {}

type Struct struct {
	Owner *Struct
	Pack     Pack
	FullType FullType
	Fields   map[FieldName]*StructField
}

type Primetive struct {
	Type string
}

type Rule struct {
	Value string
}

type MapFunc struct {
	Imports  map[Pack]Import
	Name     string
	Mappable map[Direction]*MappingRoot
	Rules    []Rule
}

type MappingRoot struct {
	Import Import
	Struct *Struct
}

const projectName = "github.com/udisondev/go-mapping-jam/"

var pkgs = make(map[Pack]*packages.Package)

func main() {
	// Путь к файлу с интерфейсом
	interfaceFile := "./mapper/mapper.go"

	// Читаем исходный код
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, interfaceFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("failed to parse file: %v", err)
	}

	imports := make(map[ImportAlias]Import)
	mapFuncs := make(map[string]MapFunc)
	imports[ImportAlias(".")] = Import{Alias: ImportAlias("."), Pack: Pack(projectName + "/mapper")}

	for _, v := range node.Imports {
		imp := extractMapImport(v)
		imports[ImportAlias(imp.Alias)] = imp
	}

	astMethods := extractMethods(node)

	for _, v := range astMethods {
		mappingRules := make([]Rule, 0, len(v.Doc.List))
		for _, mpr := range v.Doc.List {
			mappingRules = append(mappingRules, Rule{
				Value: mpr.Text,
			})
		}

		if fType, ok := v.Type.(*ast.FuncType); ok {
			source := extractMappingRoot(fType.Params, imports)
			target := extractMappingRoot(fType.Results, imports)
			m := MapFunc{
				Imports: make(map[Pack]Import),
				Name:     v.Names[0].Name,
				Mappable: map[Direction]*MappingRoot{Source: &source, Target: &target},
				Rules:    mappingRules,
			}

			mapFuncs[m.Name] = m
		}
	}

	// mapFuncs := make([]mapper, 0, len(node.Scope.Objects))

	// Ищем интерфейс Mapper и метод

	// Загружаем пакеты проекта
	cfg := &packages.Config{
		Mode: packages.NeedTypes | packages.NeedImports | packages.NeedSyntax,
		Fset: fset,
	}

	for _, v := range mapFuncs {
		packFunc := func(dir string) *packages.Package {
			pks, err := packages.Load(cfg, dir)
			if err != nil {
				panic(err)
			}
			return pks[0]
		}

		v.initRoot(v.Mappable[Source], packFunc)
		v.initRoot(v.Mappable[Target], packFunc)
	}

	// pkgs, err := packages.Load(cfg, ".")
	// if err != nil {
	// 	log.Fatalf("failed to load packages: %v", err)
	// }

	// // Извлекаем типы структур
	// var sourceType, targetType *ast.StructType
	// for _, pkg := range pkgs {
	// 	for _, syntax := range pkg.Syntax {
	// 		ast.Inspect(syntax, func(n ast.Node) bool {
	// 			if ts, ok := n.(*ast.TypeSpec); ok {
	// 				if ts.Name.Name == sourceStruct {
	// 					sourceType, _ = ts.Type.(*ast.StructType)
	// 				}
	// 				if ts.Name.Name == targetStruct {
	// 					targetType, _ = ts.Type.(*ast.StructType)
	// 				}
	// 			}
	// 			return true
	// 		})
	// 	}
	// }

	// if sourceType == nil || targetType == nil {
	// 	log.Fatalf("failed to find source or target structures")
	// }

	// // Создаем файл для генерации
	// f := jen.NewFile("mapper")
	// f.Comment("Code generated by generate.go. DO NOT EDIT.")

	// // Генерируем функцию реализации
	// f.Func().Id(fmt.Sprintf("%sImpl", methodName)).Params(jen.Id("src").Id(sourceStruct)).Qual(targetPackage, targetStruct).BlockFunc(func(g *jen.Group) {
	// 	g.Return(jen.Qual(targetPackage, targetStruct).ValuesFunc(func(values *jen.Group) {
	// 		// Динамически добавляем поля
	// 		for _, sourceField := range sourceType.Fields.List {
	// 			for _, targetField := range targetType.Fields.List {
	// 				// Проверяем совпадение имен
	// 				if len(sourceField.Names) > 0 && len(targetField.Names) > 0 &&
	// 					sourceField.Names[0].Name == targetField.Names[0].Name {
	// 					values.Id(targetField.Names[0].Name).Op(":").Id("src").Dot(sourceField.Names[0].Name)
	// 				}
	// 			}
	// 		}
	// 	}))
	// })

	// // Сохраняем сгенерированный файл
	// outputFile := filepath.Join(".", "mapper_generated.go")
	// err = f.Save(outputFile)
	// if err != nil {
	// 	log.Fatalf("failed to save generated file: %v", err)
	// }

	// log.Printf("Generated file: %s", outputFile)

}

func extractMapImport(i *ast.ImportSpec) Import {
	out := Import{}
	pack := strings.ReplaceAll(i.Path.Value, "\"", "")
	out.Pack = Pack(pack)

	if i.Name != nil {
		out.Alias = ImportAlias(i.Name.Name)
		return out
	}

	pathElements := strings.Split(pack, "/")
	lastPathElement := pathElements[len(pathElements)-1]
	out.Alias = ImportAlias(lastPathElement)

	return out
}

func extractMethods(n ast.Node) []*ast.Field {
	out := []*ast.Field{}
	ast.Inspect(n, func(n ast.Node) bool {
		if iface, ok := n.(*ast.TypeSpec); ok && iface.Name.Name == "Mapper" {
			if ifaceType, ok := iface.Type.(*ast.InterfaceType); ok {
				out = append(out, ifaceType.Methods.List...)
			}
		}
		return true
	})

	return out
}

func extractMappingRoot(v *ast.FieldList, impMap map[ImportAlias]Import) MappingRoot {
	out := MappingRoot{Struct: &Struct{Fields: make(map[FieldName]*StructField)}}
	switch expr := v.List[0].Type.(type) {
	case *ast.Ident:
		imp := impMap[ImportAlias(".")]
		out.Import = imp
		out.Struct.FullType = FullType{StructName: expr.Name}
		out.Struct.Pack = imp.Pack
	case *ast.SelectorExpr:
		imp := impMap[ImportAlias(expr.X.(*ast.Ident).Name)]
		out.Import = imp
		out.Struct.FullType = FullType{ShortPackName: expr.X.(*ast.Ident).Name, StructName: expr.Sel.Name}
		out.Struct.Pack = imp.Pack
	}

	return out
}

func (s Struct) Hash() StructHash {
	return StructHash(string(s.Pack) + "." + s.FullType.StructName)
}

func (p Pack) Dir() string {
	return fmt.Sprintf("./%s", strings.ReplaceAll(string(p), projectName, ""))
}

func (m *MapFunc) initRoot(mr *MappingRoot, packFunc func(dir string) *packages.Package) {
	pkg, ok := pkgs[mr.Struct.Pack]
	if !ok {
		pkg = packFunc(string(mr.Import.Pack.Dir()))
		pkgs[mr.Struct.Pack] = pkg
	}
	strObj, ok := pkg.Syntax[0].Scope.Objects[mr.Struct.FullType.StructName]
	if !ok {
		panic(fmt.Sprintf("has not %s TypeSpec", mr.Struct.FullType.StructName))
	}

	strTs, ok := strObj.Decl.(*ast.TypeSpec)
	if !ok {
		panic(fmt.Sprintf("%s is not a TypeSpec", mr.Struct.FullType.StructName))
	}

	st, ok := strTs.Type.(*ast.StructType)
	if !ok {
		panic("is not a struct")
	}

	for _, v := range st.Fields.List {
		field := m.buildField(nil, v, pkg.Types)
		mr.Struct.Fields[FieldName(v.Names[0].Name)] = &field
	}

	fmt.Println(strTs)
}


func (m *MapFunc) buildField(owner *Struct, astf *ast.Field, p *types.Package) StructField {
	if t, ok := astf.Type.(*ast.Ident); ok {
		if t.Obj == nil {
			return &Primetive{
				Type: t.Name,
			}
		}
	}
	t := astf.Names[0]
	if t.Obj == nil {
		return &Primetive{
			Type: t.Name,
		}
	}

	var fullType FullType
	switch ft := astf.Type.(type) {
	case *ast.SelectorExpr:
		packName, ok := ft.X.(*ast.Ident)
		if !ok {
			panic(fmt.Sprintf("could not extract pack name for %s", astf.Names[0].Name))
		}

		fullType = FullType{ShortPackName: packName.Name, StructName: ft.Sel.Name}
		imp := findImport(fullType, p)
		m.addImport(*imp)
	}

	fs := Struct{
		FullType: fullType,
	}

	if owner != nil {
		fs.Owner = owner
	}

	ts, ok := astf.Type.(*ast.StructType)
	if !ok {
		panic("is not a struct")
	}

	for _, v := range ts.Fields.List {
		field := m.buildField(&fs, v, p)
		fs.Fields[FieldName(v.Names[0].Name)] = &field
	}

	return &fs

}

func (m *MapFunc) addImport(imp Import) {
	m.Imports[imp.Pack] = imp
}

func findImport(ft FullType, p *types.Package) *Import {
	if p.Name() == ft.ShortPackName {
		return &Import{Alias: ImportAlias(p.Name()), Pack: Pack(p.Path())}
	}

	if len(p.Imports()) < 1 {
		return nil
	}

	for _, othp := range p.Imports() {
		imp := findImport(ft, othp)
		if imp != nil {
			return imp
		}
	}

	panic(fmt.Sprintf("package for %s not found: ft"))
}
